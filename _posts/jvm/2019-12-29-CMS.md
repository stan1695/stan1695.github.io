## CMS(Concurrent Mark Sweep)步骤  

CMS处理过程包括了7个步骤  
* 初始化标记（CMS Initial Mark） 会导致Stop the world。 此时只有一个线程在运行，用户线程也是停止的  
* 并发标记(CMS-concurrent-mark)，与用户线程同时运行；  
* 预清理（CMS-concurrent-preclean），与用户线程同时运行；  
* 可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；  
* 重新标记(CMS-remark) ，会导致swt；会导致stop the world 用户线程停止，但是可以有多个线程在同时在标记  
* 并发清除(CMS-concurrent-sweep)，与用户线程同时运行；  
* 并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；  

1、初始化标记做两件事：
1.1标记出能够从gc root直接到达的在老年代的第一步对象  
1.2标记出能够从gc root到达新生代再达到老年代的第一步对象  

2、并发标记：  
2.1从第一步中标记的对象开始，一直往下找引用对象，并把这些引用对象标记上，  
2.2因为此时运用程序也是运行的，所以新生代和老年代的对象都会发生变化，所以要把这些发生变化的对象收集在一个集合中  

3、预清理：标记第2步中并不能吧所以的存活对象都标记出来，只要是2.2中发生的变化的对象，没有继续往下标记引用存活对象，所以这步就是用来标记变化对象的引用对象。

4、可悲终止的预处理：这一步其实就是在停止，等待发生minor gc。这样是方便下一步做重复标记。这样下最后清理时可以清理更多的不可达对象。

5、重新标记： 第一步第二步标记的对象不会再遍历一遍，标记线程识别对象在并发阶段已经标记过了，就会跳过该对象。所以重新标记只会遍历那些新增没有标记过的活动对象和其间有指针更新的活动对象，如果指针更新频繁，重新标记很有可能会遍历新生代中的大部分甚至全部对象。所以如果重新标记阶段很慢，可以启动一次YGC（添加-XX:+CMSParallelRemarkEnabled），来减少并发标记的工作量减少其停顿时间。

6、浮动垃圾：因为 CMS 在 并发标记 时是并发的，GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（即浮动垃圾）没有被标记到；而 重新标记 的作用只是修改之前 并发标记 所获得的不可达对象，所以是没有办法处理 “浮动垃圾” 的。  

写屏障：当对象引用发生变化时，如果引用的对象没有标记，则将该引用对象标记  

重新标记（Remark） 的作用在于： 之前在并发标记时，因为是 GC 和用户程序是并发执行的，可能导致一部分已经标记为 从 GC Roots 不可达 的对象，因为用户程序的（并发）运行，又可达 了，Remark 的作用就是将这部分对象又标记为 可达对象。  

7、为什么要两次stw:分别是在初始化标记和重新标记阶段，初始化标记是为了找出gcroot直接可达对象，而重新标记是为了找出未标记中对象的所有可达对象，其中还包括在并发标记是发送变化的对象。

## 参考资料

* https://blog.csdn.net/zqz_zqz/article/details/70568819
* https://www.zhihu.com/search?type=content&q=cms%20gc