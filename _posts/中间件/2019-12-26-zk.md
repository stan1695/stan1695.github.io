## zk选举策略
* 再部署每一台zk服务器的时候，在zoo.cfg文件中都必须配置集群中各服务器的情况，比如：
  ```
    server.1=ip1:2888:3888
    server.2=ip1:2888:3888
    server.3=ip1:2888:3888
  ```
* 在启动每台zk服务器的时候，都会选举自己为leader,在没有确定leader之前，zk服务的状态为looking,
* 第一台zk服务（server1）启动时，会选举自己为leader,但是应为目前只有一台服务选择了server1为leader，不超过半数，所以leader还不确定。
* 第二台zk服务（server2）启动时，也是会选举自己为leader,他也会跟第一台服务通信，发现第一台服务的leader是server1，而自己选举的leader为server2。
* 这时server1、server2都有相互的投票信息。然后每一个server再选出一个leader,对比的规则如下：  
  
 * * 优先对比zxid,谁的zxid 越高就投给谁。  
 * * zxid如果相同，则谁的sid大就投谁。  
  
* 最后统计票数，获取投票超过一半的server就为leader。假如这时server1和server2都投了server2为leader,这样server2的leader身份就确认了。
* server2的状态就为leading,server1的状态就为following,
* 再启动server3时，因为在此之前集群的leader已经确认，集群已经开始工作，这时server3试图去选取leader时，被告知当前集群的leader信息，server3只需要跟leader建立连接，并同步状态即可。
* 还有zk服务器还有一种状态为observing，表示观察着状态，当前服务器是观察着，他不参与leader选举。

* LOOKING，竞选状态。
* FOLLOWING，随从状态，同步leader状态，参与投票。
* OBSERVING，观察状态,同步leader状态，不参与投票。
* LEADING，领导者状态。

# 使用observer模式
* 由于参与选择，需要所有的非observer服务器进行通信，如果这种服务节点越多，通信越慢。所以很多时候，一个集群参与选取的服务节点不需要很多，但是为了增强集群的读写能力，我们可以选择不断的添加observer的zk服务节点。
* 由于observer不参与选择，所以在增加或删除observer时，是不影响到选举的结果的。
* 在出现Observer之前，ZooKeeper集群的伸缩性由follower来实现。虽然对于读写操作来说，follower是"无状态"的，这使得添加新的follower到集群(或者从集群中减少follower)很方便，能提高ZooKeeper集群负载能力。但是，对于投票 来说，follower是有状态的，增、减follower的数量，都直接影响投票结果，特别是follower的数量越多，投票过程的性能就越差。  
* 如何配置observer呢
  ```
  peerType=observer
  server.1=IP:2181:3181:observer
  ```